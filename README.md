# Saucy Registrations

I've worked on a few large enterprise projects that made use of a dependency injection container. Within multiple different projects, at multiple different jobs, there existed some code to "automagically" register services with the container following some sort of convention. For example, classes that ended with "Repository" would be registered as a singleton, while classes that ended with "Service" would be registered as transient, etc. This code was always done with reflection, normally a pain to maintain, and always seemed to be a bit of a black box.

I wanted to solve the problem for myself, once and for all. I wanted to solve it with minimal performance impact, minimal configuration, and maximum readability.

Enter...this.

## What is this?

Saucy is an [incremental source generator](https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md). It provides a four attributes and a single enum.  Using these, within the assembly it's been installed into, it'll generate a class with a single extension method.  This class contains all the registrations for your services. You simply call the extension method it generates in your composition root and forget about it.


## How do I use this?

See the [samples](https://github.com/aspeckt-112/SaucyRegistrations/tree/develop/samples) for a working example. Read on if you want to know more, or you're just procrastinating at work, trying to look productive by reading documentation on GitHub.

At it's core, usage is as simple as adding a single attribute to your service class. For example:

```csharp
[SaucyInclude(ServiceScope.Singleton)]
public class ExampleClass : IExample
{
}
```

Which is turn, generates the following code:

```csharp
namespace YOUR_PROJECT.ServiceCollectionExtensions;

public static class YOUR_PROJECTServiceCollectionExtensions
{
    public static void AddYOUR_PROJECTServices(IServiceCollection services)
    {
        services.AddSingleton<IExample, ExampleClass>();
    }
}
```

You can then call this method in your composition root:

```csharp
var serviceCollection = new ServiceCollection();
serviceCollection.AddYOUR_PROJECTServices();
```

In essence, that's it. 

# But this isn't saving me much time?

At this point you may be thinking "This isn't saving me much time, I could have just written the registration code myself". And you'd be right. But the real power of Saucy comes when you have a large project with many services, in many different namespaces. To help you with this, Saucy provides another, more powerful attribute: `SaucyIncludeNamespace`.

`SaucyIncludeNamespace` is applied at the assembly level. It tells Saucy to always register classes in a specific namespace. For example:

```csharp
AssemblyInfo.cs
[assembly: SaucyIncludeNamespace(nameof(Saucy.Services), ServiceScope.Transient)]
```

With this, all classes in the `Saucy.Services` namespace will be registered as transient. Now, you can just continue to add services to that nanmespace, and they'll be registered automatically.

There's no limitation on the amount of attributes you can apply to an assembly, so you can have multiple namespaces with different scopes.

```csharp
[assembly: SaucyIncludeNamespace(nameof(Saucy.Services), ServiceScope.Transient)]
[assembly: SaucyIncludeNamespace(nameof(Saucy.Builders), ServiceScope.Singleton)]
```

Which would generate the following code:

```csharp
// <auto-generated by Saucy. DO NOT CHANGE THIS FILE!!! />
using Microsoft.Extensions.DependencyInjection;

namespace Saucy.Console.ServiceCollectionExtensions;

public static class SaucyConsoleServiceCollectionExtensions
{
    public static IServiceCollection AddSaucyConsoleServices(this IServiceCollection services)
    {
        services.AddSingleton<Saucy.Console.Builders.IBuilderInterfaceOne, Saucy.Console.Builders.ABuilder>();
        services.AddTransient<Saucy.Console.Services.IService, Saucy.Console.Services.IncludedServiceOne>();
        return services;
    }
}
```

*Note: services are registered in alphabetical order, using the fully qualified name of the class.*

If you need to override the default scope for a specific class, you can do so by applying the `SaucyInclude` attribute to the class itself. This will override the scope set by the assembly attribute.

If you're including a namespace with many classes, and you want to exclude a specific class for any reason, you can do so by applying the `SaucyExclude` attribute to the class.

```csharp
[SaucyExclude]
public class ExcludedService : IService
{

}
```

# Anything else?

Yes! By default, classes that only implement an abstract class won't be registered. I'm open to feedback on this, but from experience, I can count on one hand the times that I've actually resolved an abstract class from the container. However, if you need to register an abstract class, you can do so by applying the `SaucyRegisterAbstractClass` attribute to the class.

```csharp
[SaucyInclude(ServiceScope.Transient)]
[SaucyRegisterAbstractClass]
public class SomethingUsingTheAbstractBaseClassAndTheInterface : AbstractRegistrationBaseClass, ISomeInterface
{

}
```

If you've got a class that implements multiple interfaces, but you only want to register it as one of them, you can apply one (or more) `SaucyDoNotRegisterWithInterface` attribute(s) to the class.

```csharp
[SaucyInclude(ServiceScope.Scoped)]
[SaucyDoNotRegisterWithInterface(nameof(IService))]
public class IncludedServiceWithScopeOverride : IService
{

}
```

Doing that will register a concrete instance of `IncludedServiceWithScopeOverride` with the container, it won't register it as an `IService`.

## Support for generics?

Saucy currently supports generics at an interface level, but not at a class level. 

There's an open issue here: https://github.com/aspeckt-112/SaucyRegistrations/issues/33


#### I'm open to feedback, ideas and pull requests. Enjoy using Saucy!
