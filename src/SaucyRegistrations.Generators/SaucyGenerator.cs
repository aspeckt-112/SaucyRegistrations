using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.CodeAnalysis;

using Saucy.Common.Enums;

using SaucyRegistrations.Generators.Builders;
using SaucyRegistrations.Generators.Collections;
using SaucyRegistrations.Generators.Configurations;

using Type = SaucyRegistrations.Generators.Models.Type;

namespace SaucyRegistrations.Generators;

/// <summary>
/// The source generator for the Saucy library.
/// </summary>
[Generator]
public class SaucyGenerator : ISourceGenerator
{
    /// <summary>
    /// The initialization method for the source generator.
    /// </summary>
    /// <remarks>Not used in this source generator.</remarks>
    /// <param name="context">The generator initialization context.</param>
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required
    }

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            GenerationConfiguration? generationConfiguration = GenerationConfigurationBuilder.Build(context.Compilation);

            if (generationConfiguration is null)
            {
                // Theres nothing to generate
                return;
            }

            Assemblies assemblyCollection = AssemblyCollectionBuilder.Build(context.Compilation, generationConfiguration);

            if (assemblyCollection.IsEmpty)
            {
                // Theres nothing to generate
                return;
            }

            RunConfiguration runConfiguration = RunConfigurationBuilder.Build(generationConfiguration, assemblyCollection);
            var source = GenerateRegistrationCode(runConfiguration, context.Compilation.ObjectType);
            context.AddSource($"{runConfiguration.GenerationConfiguration.Class}.Generated.cs", source);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);

            throw;
        }
    }

    private string GenerateRegistrationCode(RunConfiguration runConfiguration, INamedTypeSymbol objectSymbol)
    {
        StringBuilder sourceBuilder = new();

        GenerationConfiguration generationConfiguration = runConfiguration.GenerationConfiguration;

        sourceBuilder.Append(
            $@"//<auto-generated by Saucy on {DateTime.Now} />
using Microsoft.Extensions.DependencyInjection;

namespace {generationConfiguration.Namespace}
{{
	public static partial class {generationConfiguration.Class}
	{{
		public static void {generationConfiguration.Method}(IServiceCollection serviceCollection)
		{{");

        sourceBuilder.AppendLine();

        Dictionary<ServiceScope, string> serviceScopeToMethodNameMap = new()
        {
            { ServiceScope.Singleton, "serviceCollection.AddSingleton" },
            { ServiceScope.Scoped, "serviceCollection.AddScoped" },
            { ServiceScope.Transient, "serviceCollection.AddTransient" },
        };

        foreach (Type type in runConfiguration.TypesToRegister)
        {
            ITypeSymbol typeSymbol = type.Symbol;
            ServiceScope typeScope = type.ServiceScope;

            var fullyQualifiedTypeName = typeSymbol.ToDisplayString();

            INamedTypeSymbol? classBaseType = typeSymbol.BaseType;

            var classHasBaseType = classBaseType is not null && !ReferenceEquals(classBaseType, objectSymbol);

            if (classHasBaseType && typeSymbol.BaseType!.IsAbstract)
            {
                var fullyQualifiedBaseTypeName = typeSymbol.BaseType.ToDisplayString();

                sourceBuilder.AppendLine($@"            {serviceScopeToMethodNameMap[typeScope]}<{fullyQualifiedBaseTypeName}, {fullyQualifiedTypeName}>();");
            }

            var classHasInterfaces = typeSymbol.Interfaces.Length > 0;

            switch (classHasInterfaces)
            {
                case true:
                    {
                        foreach (INamedTypeSymbol @interface in typeSymbol.Interfaces)
                        {
                            var fullyQualifiedInterfaceName = @interface.ToDisplayString();

                            sourceBuilder.AppendLine($@"            {serviceScopeToMethodNameMap[typeScope]}<{fullyQualifiedInterfaceName}, {fullyQualifiedTypeName}>();");
                        }

                        break;
                    }
                case false when !classHasBaseType:
                    sourceBuilder.AppendLine($@"            {serviceScopeToMethodNameMap[typeScope]}<{fullyQualifiedTypeName}>();");

                    break;
            }
        }

        sourceBuilder.AppendLine(@"        }");
        sourceBuilder.AppendLine(@"    }");
        sourceBuilder.AppendLine(@"}");

        return sourceBuilder.ToString();
    }
}